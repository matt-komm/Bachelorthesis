#LyX 1.6.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass scrreprt
\begin_preamble
\usepackage{url}
\end_preamble
\use_default_options false
\language american
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family rmdefault
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 0.5cm
\footskip 0.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
The main part of the program is the web-server.
 It's implementation has to receive and process any incoming GET or POST
 request from possible clients simultaneously.
 First, the server has to identify active clients and match them with their
 physics analysis.
 This is solved by a server-side generated id.
 Once a client sends a creation request for a new analysis to the server,
 it will receive and store this id.
 All subsequent requests have to send this id along with the request data
 to modify the correct analysis.
 
\end_layout

\begin_layout Standard
In this context, I will call a physics analysis with its id also an analysis
 session with.
 So, the user can have more analysis sessions at a time which are distinguished
 by different ids.
\end_layout

\begin_layout Standard
An example of a request is the following:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
{
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
request:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset Quotes eld
\end_inset

saveAnalysis
\begin_inset Quotes erd
\end_inset

,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
filepath:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset Quotes eld
\end_inset

user/ttbar.xml
\begin_inset Quotes erd
\end_inset

,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
session:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
\begin_inset Quotes eld
\end_inset

8ad2bf6754dfe153...
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
\size footnotesize
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The analysis session id is actualy a SHA256 hash of the timestamp at the
 generation time plus a random number.
 The id generation is easy exchangeable which lets this feature adaptive.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-management-between"

\end_inset

 visualizes the data-flow and processing of a request on the server and
 client side.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/requests.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Request management between client and web-server
\begin_inset CommandInset label
LatexCommand label
name "fig:Request-management-between"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, the incoming request will be examined whether the content-type is
 specified as 
\end_layout

\begin_layout Standard

\family typewriter
\size small
application/x-www-form-urlencoded
\family default
\size default
,
\end_layout

\begin_layout Standard
which is the common signature of a JSON request.
 In this case the server extracts the JSON object's key and value pairs.
 To find the client's analysis session, the sent id will be compared.
 The web-server delegates the request to the fittingly method for further
 processing.
 This will take care of all necessary actions and send the result data back
 to the client.
 In the example above, a method is called to save the pxl::Analysis to the
 specified file path, 
\family typewriter
\size footnotesize
'user/ttbar.xml'
\family default
\size default
.
 If an exception occures during the processing of a request, the server
 can send an error message back to the client.
 This message is also passed to the onSuccess method of the client by the
 AJAX engine.
 Therefore, it has to be distinguish from successfully returned result data.
\end_layout

\begin_layout Standard
The AJAX engine will call the onFailure method, if the POST request has
 not reached the server or no response has been send in the timeout.
 This may happen for example, if the connection between them is abruptly
 lost.
 So, in fact, the client has to manage two different levels of exception
 handling.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/startup.eps
	lyxscale 50
	scale 45
	rotateAngle 90
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Client: Getting an id
\begin_inset CommandInset label
LatexCommand label
name "fig:Client:-Getting-an"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As stated above, every client needs a valid id to get a request processed.
 Therefore, I like to elaborate what happens exactly when new clients connect
 for the first time to the server and how they receive an id with an associated
 analysis session.
 Here for security reasons, a major requirement was to realize different
 enviroments for a guest and a registered user.
 The flow chart in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Client:-Getting-an"

\end_inset

 demonstrates the chosen implementation.
\end_layout

\begin_layout Standard
At first a login with a username password pair is required to distinguish
 between the two user types.
 A guest needs no password and receives after the successfully returned
 login request his analysis session id.
 If a user is registered and enters his username and password, both will
 be sent to the server for authentication.
 If the user has loggedin before the response of the server includes all
 of his previously saved XML analysis files.
 Then he can create a new physics analysis or load and work further on an
 existing one.
 In both cases, the server will send a analysis session id back as well.
 For security reasons, the password is not transmitted in plain text.
 At the start, the client will save the current timestamp.
 The entered password will be concatenated to the timestamp and a SHA256
 hash is calculated.
 The server will receive both, hash and timestamp, and can then easily generate
 and compare the stored user's password by computing the same hash.
\end_layout

\begin_layout Section
Analysis Session Management
\end_layout

\begin_layout Standard
For working with many different analysis sessions simultaneously a system
 is needed that controls and organizes analysis sessions automatically.
 The concept for handling a single analysis was even present during the
 work with PXL 2.5.6.
 So the pxl::Analysis class was introduced with PXL 3.0.
 For more flexibility, I created the AnalysisSession class to wrap methods
 of the pxl::Analysis class and to implement more concepts like the analysis
 session id or the file handling with the file-system.
\end_layout

\begin_layout Standard
It is convenient to introduce a pool where all active analysis sessions
 are maintained.
 In this context I distinguish between an active and a dead analysis session.
 All analysis sessions have a timestamp of their last modification.
 To save memory and prevent the loss of data if the program crashes, analysis
 sessions can be saved to disk and removed from the analysis session pool
 if they are not modified for a specified time.
 These analysis sessions are marked as dead.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Communication-between-Session"

\end_inset

 demonstrates the interaction of the pool and the analysis  session class.
 For clarity, methods which support modifications, like the creation of
 new modules for the pxl::Analysis object, are left out in this diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/sessionmanagement.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Interaction between SessionPool and AnalysisSession
\begin_inset CommandInset label
LatexCommand label
name "fig:Communication-between-Session"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The analysis session pool manages mainly the creation of new analysis sessions.
 It can create an empty analysis session or generate a analysis session
 from a XML file.
 If a analysis session is requested by the getAnalysis method, its timestamp
 will be updated and moved to the bottom of the analysisList.
 This has the effect that this list is automatically sorted by the time
 of inactivity.
 So, possible dead analysis sessions can easily be found at the top.
\end_layout

\begin_layout Section
File handling
\end_layout

\begin_layout Standard
PXL provides its own data format with the extension, 'pxlio'.
 The structure of a pxlio file is divided into chunks.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PXLIO-file:-Possible"

\end_inset

 shows an example of a possible constitution for a pxlio file with two chunks.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/pxliofiles.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PXLIO file: Possible internal structure
\begin_inset CommandInset label
LatexCommand label
name "fig:PXLIO-file:-Possible"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In a pxlio file, there exists no global header which leaves the file readable
 even when the writing process was interrupted.
 Each chunk consists of data blocks with one or more serialized objects.
\end_layout

\begin_layout Standard
To access these information and send it back to the client in an easy parsable
 format, I implemented the PxlIOReader class.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-PxlIOReader"

\end_inset

 shows the current class structure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/pxlioreader.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The PxlIOReader
\begin_inset CommandInset label
LatexCommand label
name "fig:The-PxlIOReader"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The _readEvent() method will build the accessed information of the current
 pxl::Event at the index position of the file together in the format which
 is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-data-format"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/event_format.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
The data format of the PxlIOReader class
\begin_inset CommandInset label
LatexCommand label
name "fig:The-data-format"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This format is highly flexible because particle properties are saved in
 arrays of property names and values.
 Therefore it can easily be adapted to more or less information to send.
 For example, if a pxl::Event includes over hundred pxl::Particles the user
 might not be interested in all information there is.
\end_layout

\begin_layout Standard
If all arrays of name and value pairs are empty, the format contains the
 minimum of possible information but the client can still process it.
\end_layout

\begin_layout Section
Job management
\end_layout

\begin_layout Standard
For performing parallel analysis, a multiprocessing job management is needed
 to prevent the web-server from crashing if an analysis breaks down.
 I created a job pool similar to the analysis session pool.
 Every user can submit a pxl::Analysis to this pool for execution.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Multiprocessing-with-the"

\end_inset

 displays the complex submission and execution process.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/jobsystem.eps
	lyxscale 40
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Multiprocessing with the JobPool class
\begin_inset CommandInset label
LatexCommand label
name "fig:Multiprocessing-with-the"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pool runs mainly in a separated thread to control the maximum number
 of parallel working processes.
 Submitted jobs will be enqueued and wait for their execution.
 Every second the pool will look for new jobs in that list and execute them
 if the maximum number of parallel jobs is not yet reached.
 Otherwise the jobs will remain in that list until an already running job
 has finished.
 It is convenient to set the number of the allowed parallel running jobs
 to the server's core count for an effective use of the available computing
 resources.
\end_layout

\begin_layout Standard
To prevent data loss if a user submits a job during the pool is accessing
 the list, a lock is introduced.
 If the user or the pool access the list, it acquires the lock.
 If the other tries to acquire the lock as well, it has to wait until the
 lock is released.
\end_layout

\begin_layout Standard
The output stream of a job can easily be caught by using the new logging
 mechanism of PXL 3.0.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:The-Logging-system"

\end_inset

 demonstrates this new feature and how it works.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename pics/logging.eps
	lyxscale 50
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption

\begin_layout Plain Layout
The Logging system of PXL
\begin_inset CommandInset label
LatexCommand label
name "fig:The-Logging-system"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To send a log entry, a pxl::Logger object has to be initialized with the
 module's name.
 The pxl::Logger can be called with a specific log level and the message
 to log.
 The global pxl::LogDispatcher will only distribute incoming messages from
 a pxl::Logger to all registered pxl::LogHandler up to the highest set log
 level by handler.
\end_layout

\begin_layout Standard
I created the HTMLLogHandler class for catching the output and displaying
 it to the user.
 The class inherits from the pxl::LogHandler and is registered to the pxl::LogDi
spatcher.
 It generates a HTML page from the incoming logging messages and displays
 it color-coded by the log level.
 To distinguish between the logging of different users, the pxl::LogDispatcher
 exists for each job process separately.
 This was also an argument for the implementation of a multiprocessing instead
 of a multithreading job management.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ifnum
\backslash
value{chapter}<1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "amsplain"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
fi
\end_layout

\end_inset


\end_layout

\end_body
\end_document
